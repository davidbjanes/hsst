classdef UltraMegaSort2000 < hsst.sorter
    
    properties (Constant)
        
        sortMethodLabel = 'UltraMegaSort2k';
        defaultParameters = [1 5 10 50 100 500 1000]*5e-5;
    end 
        
    methods (Static)
        
        function [sort_ids, wf, ts, property] = sort(wf, ts, Fs, thresh, ...
                                     align_sample, dur, raw_data, ...
                                     sortparameter)
            
            import hsst.sortMethod.UltraMegaSort2000.*
                                 
            if length(ts) ~= size(wf, 2),
                wf = wf';
            end
                                 
            spikes = ss_default_params(Fs);
            
            % UMS2000 Interface ===============================================
            if isempty(raw_data)
                aligned_wf = alignment_function(wf,11);
                if isempty(aligned_wf)
                    % this can be empty if the operators filtered all spikes
                    return;
                end
                nSnips   = size(aligned_wf,2);
                nSamples = size(aligned_wf,1);

                spikes.waveforms  = aligned_wf';
                spikes.spiketimes = ts;
                spikes.trials     = ones(1,nSnips);
                
                % CAA TODO These aren't really used
                spikes.params.max_jitter   = 3/Fs*1e3;
                spikes.params.window_size  = (nSamples)/Fs*1e3;   % ms, width of a spike
                spikes.params.shadow       = 2/Fs*1e3;            % ms, enforced dead region after each spike
                spikes.params.cross_time   = 0/Fs*1e3;            % ms, alignment point for peak of waveform

                % spikes.info.detect.stds          = 28.8141
                spikes.info.detect.thresh        = thresh;
                spikes.info.detect.event_chann   = ones(nSnips,1);
                spikes.info.detect.dur           = dur;
                spikes.info.detect.align_sample  = align_sample;
                spikes.unwrapped_times           = ts;
                
                % these values are ordinarily generated by the
                % align function
                [pca.u,pca.s,pca.v] = svd(detrend(spikes.waveforms(:,:),'constant'), 0);             % SVD the data matrix
                spikes.info.pca = pca;
                
            else
                % turn operators off because the spike times are extracted from
                % the raw data
                spikes      = ss_detect(raw_data,spikes);
                spikes      = ss_align(spikes);

            end

            % disable progress bars to reduce runtime
            options.progress = false;
        
            spikes = ss_kmeans(spikes,options);
            spikes = ss_energy(spikes,options);
                
            % Additive Noise Parameter
            try
                spikes.params.agg_cutoff    = sortparameter;
                spikes                      = ss_aggregate(spikes);
                sort_ids                    = spikes.assigns;
            catch ME
                simpleExceptionDisplay(ME);
                sort_ids = ones([1 length(spikes.spiketimes)]);
                formattedWarning('!!!! SORTCODE with Param = %s has triggered this fault: ''%s'' !!!!', ...
                    label{1,1}, ME.message);
            end            
            
            sort_ids;
            wf = spikes.waveforms';
            ts = spikes.spiketimes;
            property = spikes;
            
        end
        
    end
    
end

